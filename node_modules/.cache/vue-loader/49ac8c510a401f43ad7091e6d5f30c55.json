{"remainingRequest":"/home/bonifacio/code/service_bundle_frontend/node_modules/@vue/cli-service/lib/config/vue-loader-v15-resolve-compat/vue-loader.js??vue-loader-options!/home/bonifacio/code/service_bundle_frontend/src/components/ServiceDetails.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/bonifacio/code/service_bundle_frontend/src/components/ServiceDetails.vue","mtime":1698026475354},{"path":"/home/bonifacio/code/service_bundle_frontend/node_modules/babel-loader/lib/index.js","mtime":1692833949708},{"path":"/home/bonifacio/code/service_bundle_frontend/node_modules/cache-loader/dist/cjs.js","mtime":1692838039149},{"path":"/home/bonifacio/code/service_bundle_frontend/node_modules/@vue/cli-service/lib/config/vue-loader-v15-resolve-compat/vue-loader.js","mtime":1692833961693}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCB7IHJlcXVpcmVkLCBoZWxwZXJzIH0gZnJvbSAnQHZ1ZWxpZGF0ZS92YWxpZGF0b3JzJzsKaW1wb3J0IHsgdXNlVnVlbGlkYXRlIH0gZnJvbSAnQHZ1ZWxpZGF0ZS9jb3JlJwppbXBvcnQgRGF0ZXBpY2tlciBmcm9tICd2dWVqcy1kYXRlcGlja2VyJzsKaW1wb3J0IFZ1ZTJUaW1lcGlja2VyIGZyb20gJ3Z1ZTItdGltZXBpY2tlcic7CmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnU2VydmljZURldGFpbHMnLAogIHNldHVwICgpIHsgcmV0dXJuIHsgdiQ6IHVzZVZ1ZWxpZGF0ZSgpIH0gfSwKICBjb21wb25lbnRzOiB7IAogICAgRGF0ZXBpY2tlciwKICAgIFZ1ZTJUaW1lcGlja2VyLAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIHRpbWVzbG90OiBbXSwKICAgICAgZGF0YTogW10sCiAgICAgIGRhdGVfY2hlY2tlZDogZmFsc2UsCiAgICAgIG1pblRpbWU6ICcnLAogICAgICBtYXhUaW1lOiAnJywKICAgICAgZHVyYXRpb246ICcnLAogICAgICB0aW1lOiAnJywKICAgICAgYXZhaWxhYmxlX3RpbWVzbG90OiBbXSwKICAgICAgZGF0ZTogJycsCiAgICAgIHNlcnZpY2U6ICcnLAogICAgICBkaXNwbGF5U2VydmljZTogJycsCiAgICAgIG9wZW5fdGltZTogZmFsc2UsCiAgICAgIHNsb3Q6IDAsCiAgICAgIGVycl9tZXNzYWdlOiAnJywKICAgICAgZXJyX25vdGlmOiBmYWxzZSwKICAgIH0KICB9LCAKICB2YWxpZGF0aW9ucygpIHsKICAgIGNvbnN0IG1pbl90aW1lID0gdmFsdWUgPT4gewogICAgICBjb25zdCBzZWxlY3RlZFRpbWUgPSBuZXcgRGF0ZShgMTk3MC0wMS0wMVQke3RoaXMuY29udmVydFRvMjRIb3VyRm9ybWF0KHZhbHVlKX1gKTsKICAgICAgY29uc29sZS5sb2coJ21pbl90aW1lIHZhbDogJywgdmFsdWUsIHRoaXMubWluVGltZSkKICAgICAgY29uc3QgbWludGltZSA9IG5ldyBEYXRlKGAxOTcwLTAxLTAxVCR7dGhpcy5jb252ZXJ0VG8yNEhvdXJGb3JtYXQodGhpcy5taW5UaW1lKX1gKTsKICAgICAgY29uc29sZS5sb2coJ21pbl90aW1lIHJlc3VsdDogJywgc2VsZWN0ZWRUaW1lID49IG1pbnRpbWUpCiAgICAgIHJldHVybiBzZWxlY3RlZFRpbWUgPj0gbWludGltZTsKICAgIH07CiAgICBjb25zdCBtYXhfdGltZSA9IHZhbHVlID0+IHsKICAgICAgY29uc3Qgc2VsZWN0ZWRUaW1lID0gbmV3IERhdGUoYDE5NzAtMDEtMDFUJHt0aGlzLmNvbnZlcnRUbzI0SG91ckZvcm1hdCh2YWx1ZSl9YCk7CiAgICAgIGNvbnNvbGUubG9nKCdtYXhfdGltZSB2YWw6ICcsIHZhbHVlLCB0aGlzLm1heFRpbWUpCiAgICAgIGNvbnN0IG1heHRpbWUgPSBuZXcgRGF0ZShgMTk3MC0wMS0wMVQke3RoaXMuY29udmVydFRvMjRIb3VyRm9ybWF0KHRoaXMubWF4VGltZSl9YCk7CiAgICAgIGNvbnNvbGUubG9nKCdtYXhfdGltZSByZXN1bHQ6ICcsIHNlbGVjdGVkVGltZSA8PSBtYXh0aW1lKQogICAgICByZXR1cm4gc2VsZWN0ZWRUaW1lIDw9IG1heHRpbWU7CiAgICB9OwogICAgcmV0dXJuIHsKICAgICAgdGltZTogewogICAgICAgIHJlcXVpcmVkLAogICAgICAgIC8vIHZhbGlkVGltZSh2YWx1ZSkgewogICAgICAgIC8vICAgY29uc3QgdGltZVBhdHRlcm4gPSAvXihbMDFdXGR8MlswLTNdKTooWzAtNV1cZCkkLzsKICAgICAgICAvLyAgIHJldHVybiB0aW1lUGF0dGVybi50ZXN0KHZhbHVlKTsKICAgICAgICAvLyB9LAogICAgICAgIG1pbl90aW1lOiBoZWxwZXJzLndpdGhNZXNzYWdlKCdUaGUgbWluIHRpbWUgbXVzdCBiZSAnICsgdGhpcy5taW5UaW1lLCBtaW5fdGltZSkgLCAgICAgCiAgICAgICAgbWF4X3RpbWU6IGhlbHBlcnMud2l0aE1lc3NhZ2UoJ1RoZSBtYXggdGltZSBtdXN0IGJlICcgKyB0aGlzLm1heFRpbWUsIG1heF90aW1lKSAsICAgICAKICAgICAgfSwKICAgIH0KICB9LAogIG1ldGhvZHM6IHsKICAgIGhhbmRsZUVycm9yKGVyck1zZykgewogICAgICB0aGlzLmVycl9tZXNzYWdlID0gZXJyTXNnOwogICAgICB0aGlzLmVycl9ub3RpZiA9IHRydWU7CiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lcnJfbm90aWYgPSBmYWxzZSwgMTAwMDApOwogICAgfSwKICAgIGlzVGltZUluRm9ybWF0KCkgewogICAgICBjb25zdCB0aW1lUGF0dGVybiA9IC9eKDBbMS05XXwxWzAtMl0pOlswLTVdWzAtOV06WzAtNV1bMC05XSAoQU18UE0pJC87CiAgICAgIHJldHVybiB0aW1lUGF0dGVybi50ZXN0KHRoaXMudGltZSk7CiAgICB9LAogICAgb25UaW1lU2VsZWN0ZWQoKSB7CiAgICAgIHRoaXMudGltZSA9IHRoaXMuY29udmVydFRvMTJIb3VyRm9ybWF0KHRoaXMudGltZSk7CiAgICB9LAogICAgYXN5bmMgY3JlYXRlX2NhcnRfaXRlbSgpIHsKICAgICAgdHJ5IHsKICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlOwogICAgICAgIGNvbnN0IHNlcnZpY2VfaWQgPSB0aGlzLnNlcnZpY2UuaWQ7CiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMudGltZTsKICAgICAgICBjb25zb2xlLmxvZygnc2VydmljZWlkIGlzICcsIHNlcnZpY2VfaWQpCiAgICAgICAgY29uc29sZS5sb2coJ2RhdGUgJywgZGF0ZSk7CiAgICAgICAgY29uc29sZS5sb2coJ3RpbWUgJywgdGltZSkKCiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRhcG9sbG8ubXV0YXRlKHsKICAgICAgICAgIG11dGF0aW9uOiByZXF1aXJlKCdAL2dyYXBocWwvQ2FydEl0ZW1DcmVhdGUuZ3FsJyksCiAgICAgICAgICB2YXJpYWJsZXM6IHsKICAgICAgICAgICAgc2VydmljZUlkOiBzZXJ2aWNlX2lkLAogICAgICAgICAgICBkYXRlOiBkYXRlLAogICAgICAgICAgICB0aW1lOiB0aW1lLAogICAgICAgICAgfSwKICAgICAgICB9KTsKICAgICAgICBjb25zb2xlLmxvZygncmVzcG9uc2UgZnJvbSBzZXJ2ZXIgY3JlYXRlIGNhcnQgaXRlbScscmVzcG9uc2UpOwogICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmNyZWF0ZUNhcnRJdGVtLmVycm9ycy5sZW5ndGggPCAxKSB7CiAgICAgICAgICBhbGVydCgnSXRlbSBhZGRlZCB0byB0aGUgY2FydCBzdWNjZXNzZnVsbHkhJyk7CiAgICAgICAgICAvLyB0aGlzLiRyb3V0ZXIucHVzaCgnL2NhcnQnKQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLmRhdGEuY3JlYXRlQ2FydEl0ZW0uZXJyb3JzWzBdKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlX2NhcnRfaXRlbTonLCBlcnJvcik7CiAgICAgICAgLy8gSGFuZGxlIHRoZSBlcnJvciBoZXJlLCBlLmcuLCBzaG93IGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHVzZXIuCiAgICAgIH0KICAgIH0sCiAgICBjb252ZXJ0VG8yNEhvdXJGb3JtYXQodGltZTEyKSB7CiAgICAgIC8vIFNwbGl0IHRoZSBpbnB1dCB0aW1lIGludG8gaG91cnMsIG1pbnV0ZXMsIGFuZCBBTS9QTSBwYXJ0cwogICAgICBjb25zdCBbdGltZVBhcnQsIGFtcG1dID0gdGltZTEyLnNwbGl0KCcgJyk7CiAgICAgIGNvbnN0IFtob3VycywgbWludXRlcywgc2Vjb25kc10gPSB0aW1lUGFydC5zcGxpdCgnOicpOwoKICAgICAgLy8gUGFyc2UgdGhlIGhvdXJzIGFzIGFuIGludGVnZXIKICAgICAgbGV0IGNvbnZlcnRlZEhvdXJzID0gcGFyc2VJbnQoaG91cnMsIDEwKTsKCiAgICAgIC8vIEFkanVzdCB0aGUgaG91cnMgYmFzZWQgb24gQU0gb3IgUE0KICAgICAgaWYgKGFtcG0udG9VcHBlckNhc2UoKSA9PT0gJ1BNJyAmJiBjb252ZXJ0ZWRIb3VycyAhPT0gMTIpIHsKICAgICAgICBjb252ZXJ0ZWRIb3VycyArPSAxMjsKICAgICAgfSBlbHNlIGlmIChhbXBtLnRvVXBwZXJDYXNlKCkgPT09ICdBTScgJiYgY29udmVydGVkSG91cnMgPT09IDEyKSB7CiAgICAgICAgY29udmVydGVkSG91cnMgPSAwOwogICAgICB9CiAgICAgIC8vIENyZWF0ZSB0aGUgMjQtaG91ciBmb3JtYXQgdGltZSBzdHJpbmcKICAgICAgY29uc3QgY29udmVydGVkVGltZSA9IGAke1N0cmluZyhjb252ZXJ0ZWRIb3VycykucGFkU3RhcnQoMiwgJzAnKX06JHttaW51dGVzfToke3NlY29uZHN9YDsKCiAgICAgIHJldHVybiBjb252ZXJ0ZWRUaW1lOwogICAgfSwKICAgIGNvbnZlcnRUbzEySG91ckZvcm1hdCh0aW1lMjQpIHsKICAgICAgY29uc3QgW2hvdXJzLCBtaW51dGVzXSA9IHRpbWUyNC5zcGxpdCgiOiIpOwogICAgICBsZXQgYW1wbSA9ICJBTSI7CiAgICAgIGxldCBjb252ZXJ0ZWRIb3VycyA9IHBhcnNlSW50KGhvdXJzLCAxMCk7CiAgICAgIGlmIChjb252ZXJ0ZWRIb3VycyA+PSAxMikgewogICAgICAgIGFtcG0gPSAiUE0iOwogICAgICAgIGlmIChjb252ZXJ0ZWRIb3VycyA+IDEyKSB7CiAgICAgICAgICBjb252ZXJ0ZWRIb3VycyAtPSAxMjsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoY29udmVydGVkSG91cnMgPT09IDApIHsKICAgICAgICBjb252ZXJ0ZWRIb3VycyA9IDEyOyAvLyBNaWRuaWdodCBpbiAxMi1ob3VyIGZvcm1hdCBpcyAxMjowMCBBTQogICAgICB9CiAgICAgIGNvbnN0IG5ld190aW1lID0gYCR7U3RyaW5nKGNvbnZlcnRlZEhvdXJzKS5wYWRTdGFydCgyLCAiMCIpfToke21pbnV0ZXN9OjAwICR7YW1wbX1gOwogICAgICByZXR1cm4gbmV3X3RpbWU7CiAgICB9LAogICAgYXN5bmMgc3VibWl0Rm9ybSgpIHsKICAgICAgdGhpcy5taW5UaW1lID0gdGhpcy5jb252ZXJ0VG8xMkhvdXJGb3JtYXQodGhpcy5taW5UaW1lKTsKICAgICAgdGhpcy5tYXhUaW1lID0gdGhpcy5jb252ZXJ0VG8xMkhvdXJGb3JtYXQodGhpcy5tYXhUaW1lKTsKICAgICAgdGhpcy52JC50aW1lLiR0b3VjaCgpOwogICAgICBpZiAodGhpcy52JC4kZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InKTsKICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgdGltZTogJywgdGhpcy50aW1lKTsKICAgICAgICBjb25zb2xlLmxvZygnZXJyb3Jtc2c6ICcsIHRoaXMudiQuJGVycm9ycyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVfY2FydF9pdGVtKCk7CiAgICAgIH0KICAgICAgdGhpcy5taW5UaW1lID0gdGhpcy5jb252ZXJ0VG8yNEhvdXJGb3JtYXQodGhpcy5taW5UaW1lKTsKICAgICAgdGhpcy5tYXhUaW1lID0gdGhpcy5jb252ZXJ0VG8yNEhvdXJGb3JtYXQodGhpcy5tYXhUaW1lKTsKICAgICAgY29uc3QgdGltZTI0ID0gdGhpcy50aW1lLnRyaW0oKTsKICAgICAgaWYgKHRpbWUyNC5tYXRjaCgvXlxkezJ9OlxkezJ9JC8pKSB7CiAgICAgICAgdGhpcy5jb252ZXJ0ZWRUaW1lID0gdGhpcy5jb252ZXJ0VG8xMkhvdXJGb3JtYXQodGltZTI0KTsKICAgICAgfQogICAgICBjb25zb2xlLmxvZygnVVBEQVRFRCBUSU1FOiAnLHRoaXMuY29udmVydGVkVGltZSk7CiAgICB9LAogICAgc3RhcnRIb3VyKCl7CiAgICAgIGlmICh0aGlzLmRhdGUgPT0gdGhpcy5kYXRlVG9kYXkoKSkgewogICAgICAgIGNvbnN0IGhvdXIgPSB0aGlzLmdldEN1cnJlbnRIb3VyKCk7CiAgICAgICAgaWYgKGhvdXIgPj0gcGFyc2VJbnQodGhpcy5taW5UaW1lLnNwbGl0KCI6IilbMF0sIDEwKSkgcmV0dXJuIGhvdXIgKyAxOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLm1pblRpbWUuc3BsaXQoIjoiKVswXSwgMTApOwogICAgICB9CiAgICB9LAogICAgZW5kSG91cigpewogICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5tYXhUaW1lLnNwbGl0KCI6IilbMF0sIDEwKTsKICAgIH0sCiAgICBkaXNhYmxlX2RhdGVfYnlfc2xvdF9mdW5jKCkgewogICAgICAvLyBjb25zb2xlLmxvZygnRElTQUJMRSBEQVRFIEJZIFNMT1QgRlVOQyAnKQogICAgICBjb25zdCBzZXJ2aWNlX2NhdGVnb3J5ID0gW3RoaXMuZGF0YV07CiAgICAgIGxldCBkaXNhYmxlX2RhdGVfYnlfc2xvdCA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2aWNlX2NhdGVnb3J5Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZXJ2aWNlX2NhdGVnb3J5W2ldLmNhcnRJdGVtVGFsbHkubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIC8vIFVzZSBmaW5kRGF0ZVJhbmdlSW5kZXggdG8gY2hlY2sgaWYgdGhlIGRhdGUgaXMgaW4gdGhlIHJhbmdlCiAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmZpbmREYXRlUmFuZ2VJbmRleChzZXJ2aWNlX2NhdGVnb3J5W2ldLnRpbWVTbG90LCBzZXJ2aWNlX2NhdGVnb3J5W2ldLmNhcnRJdGVtVGFsbHlbal0uZGF0ZSk7CiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7CiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0aGUgZGF0ZTogJywgc2VydmljZV9jYXRlZ29yeVtpXS5jYXJ0SXRlbVRhbGx5W2pdLmRhdGUsICcgZm91bmQgaW4gJywgc2VydmljZV9jYXRlZ29yeVtpXS50aW1lU2xvdFtpbmRleF0uc3RhcnREYXRlLHNlcnZpY2VfY2F0ZWdvcnlbaV0udGltZVNsb3RbaW5kZXhdLmVuZERhdGUpCiAgICAgICAgICAgIGxldCBjYXBhY2l0eSA9IHNlcnZpY2VfY2F0ZWdvcnlbaV0udGltZVNsb3RbaW5kZXhdLmNhcGFjaXR5OwogICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY2FwYWNpdHkgPj0gc2VydmljZV9jYXRlZ29yeVtpXS5jYXJ0SXRlbVRhbGx5W2pdLmNvdW50JyxjYXBhY2l0eSA+PSBzZXJ2aWNlX2NhdGVnb3J5W2ldLmNhcnRJdGVtVGFsbHlbal0uY291bnQsY2FwYWNpdHksc2VydmljZV9jYXRlZ29yeVtpXS5jYXJ0SXRlbVRhbGx5W2pdLmNvdW50KQogICAgICAgICAgICBpZiAoc2VydmljZV9jYXRlZ29yeVtpXS5jYXJ0SXRlbVRhbGx5W2pdLmNvdW50ID49IGNhcGFjaXR5KSBkaXNhYmxlX2RhdGVfYnlfc2xvdC5wdXNoKHNlcnZpY2VfY2F0ZWdvcnlbaV0uY2FydEl0ZW1UYWxseVtqXS5kYXRlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc29sZS5sb2coJ2Rpc2FibGVfZGF0ZV9ieV9zbG90OiAnLGRpc2FibGVfZGF0ZV9ieV9zbG90KQogICAgICByZXR1cm4gZGlzYWJsZV9kYXRlX2J5X3Nsb3Q7CiAgICB9LAogICAgZm9ybWF0X2RhdGUocGFyYW1zKSB7CiAgICAgIHJldHVybiBwYXJhbXMuZGF0ZQogICAgfSwKICAgIGZvcm1hdExvbmdEYXRlKGRhdGVTdHJpbmcpIHsKICAgICAgY29uc3QgZGF0ZU9iamVjdCA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpOwoKICAgICAgLy8gR2V0IHRoZSB5ZWFyLCBtb250aCwgYW5kIGRheSBjb21wb25lbnRzCiAgICAgIGNvbnN0IHllYXIgPSBkYXRlT2JqZWN0LmdldEZ1bGxZZWFyKCk7CiAgICAgIGNvbnN0IG1vbnRoID0gKGRhdGVPYmplY3QuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgIjAiKTsgLy8gQWRkaW5nIDEgYmVjYXVzZSBtb250aHMgYXJlIDAtYmFzZWQKICAgICAgY29uc3QgZGF5ID0gZGF0ZU9iamVjdC5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAiMCIpOwoKICAgICAgLy8gQ3JlYXRlIHRoZSAiWVlZWS1NTS1ERCIgZm9ybWF0dGVkIGRhdGUgc3RyaW5nCiAgICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gOwogICAgfSwKICAgIGdldEN1cnJlbnRIb3VyKCkgewogICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7CiAgICAgIGNvbnN0IGN1cnJlbnRIb3VyID0gY3VycmVudERhdGUuZ2V0SG91cnMoKTsKCiAgICAgIHJldHVybiBwYXJzZUludChjdXJyZW50SG91cik7CiAgICB9LAogICAgZGF0ZVRvZGF5KCkgewogICAgICAvLyBDcmVhdGUgYSBEYXRlIG9iamVjdCB3aXRoIHRoZSBkZXNpcmVkIGRhdGUgKGUuZy4sIHRoZSBjdXJyZW50IGRhdGUpCiAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTsKCiAgICAgIC8vIEdldCB0aGUgZGF5LCBtb250aCwgYW5kIHllYXIgY29tcG9uZW50cwogICAgICBjb25zdCBkYXkgPSBjdXJyZW50RGF0ZS5nZXREYXRlKCk7IC8vIDEtMzEKICAgICAgY29uc3QgbW9udGggPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMTsgLy8gMC0xMSAoSmFudWFyeSBpcyAwLCBzbyBhZGQgMSkKICAgICAgY29uc3QgeWVhciA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7IC8vIDQtZGlnaXQgeWVhcgogICAgICBjb25zdCBmb3JtYXR0ZWREYXkgPSBTdHJpbmcoZGF5KS5wYWRTdGFydCgyLCAnMCcpOwogICAgICBjb25zdCBmb3JtYXR0ZWRNb250aCA9IFN0cmluZyhtb250aCkucGFkU3RhcnQoMiwgJzAnKTsKICAgICAgcmV0dXJuIGAke3llYXJ9LSR7Zm9ybWF0dGVkTW9udGh9LSR7Zm9ybWF0dGVkRGF5fWA7CiAgICB9LAogICAgcGFyc2VUaW1lKHRpbWVTdHIpIHsKICAgICAgY29uc3QgW2hvdXJzLCBtaW51dGVzXSA9IHRpbWVTdHIuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTsKICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7CiAgICAgIGRhdGUuc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIDAsIDApOwogICAgICByZXR1cm4gZGF0ZTsKICAgIH0sCiAgICBjcmVhdGVBdmFpbGFibGVUaW1lU2xvdChzdGFydF90aW1lX3N0ciwgZW5kX3RpbWVfc3RyLCBkdXJhdGlvbiwgaW50ZXJ2YWwsIGRhdGVfc2VsZWN0ZWQsIGl0ZW0pIHsKICAgICAgY29uc3QgZGF0ZV9zZWxlY3RlZF9mb3JtYXR0ZWQgPSB0aGlzLmZvcm1hdExvbmdEYXRlKGRhdGVfc2VsZWN0ZWQpOwogICAgICBjb25zdCBob3VyID0gdGhpcy5nZXRDdXJyZW50SG91cigpOwogICAgICBsZXQgZWRpdGVkX3N0YXJ0X3RpbWUgPSAwOwogICAgICBpZiAodGhpcy5kYXRlVG9kYXkoKSA9PSBkYXRlX3NlbGVjdGVkX2Zvcm1hdHRlZCkgewogICAgICAgIGNvbnN0IHRpbWVDb21wb25lbnRzID0gc3RhcnRfdGltZV9zdHIuc3BsaXQoIjoiKTsKICAgICAgICAvLyBFeHRyYWN0IHRoZSBob3VyIGNvbXBvbmVudCAodGhlIGZpcnN0IGVsZW1lbnQgYWZ0ZXIgc3BsaXR0aW5nKQogICAgICAgIGNvbnN0IHNlbGVjdGVkSG91ciA9IHBhcnNlSW50KHRpbWVDb21wb25lbnRzWzBdLCAxMCk7CiAgICAgICAgaWYgKGhvdXIgPj0gc2VsZWN0ZWRIb3VyKSB7CiAgICAgICAgICBjb25zb2xlLmxvZyhob3VyID49IHN0YXJ0X3RpbWVfc3RyLCAnSE9VUicpCiAgICAgICAgICBlZGl0ZWRfc3RhcnRfdGltZSA9IGAke2hvdXIgKyAxfTowMDowMGA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnNvbGUubG9nKCdlZGl0ZWRfc3RhcnRfdGltZScsZWRpdGVkX3N0YXJ0X3RpbWUpCiAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0ZVRvZGF5KCkgPT0gZGF0ZV9zZWxlY3RlZF9mb3JtYXR0ZWQsdGhpcy5kYXRlVG9kYXkoKSxkYXRlX3NlbGVjdGVkX2Zvcm1hdHRlZCkKICAgICAgaWYgKGR1cmF0aW9uID09IG51bGwpIGR1cmF0aW9uID0gMDsKICAgICAgY29uc3QgYXZhaWxhYmxlVGltZVNsb3RzID0gW107CiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGVkaXRlZF9zdGFydF90aW1lID09IDAgPyB0aGlzLnBhcnNlVGltZShzdGFydF90aW1lX3N0cikgOiB0aGlzLnBhcnNlVGltZShlZGl0ZWRfc3RhcnRfdGltZSk7CiAgICAgIGNvbnNvbGUubG9nKCdzdGFydFRpbWU6ICcsIHN0YXJ0VGltZSwgJ3RoaXMucGFyc2VUaW1lKHN0YXJ0X3RpbWVfc3RyKTogJywgdGhpcy5wYXJzZVRpbWUoc3RhcnRfdGltZV9zdHIpKQogICAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5wYXJzZVRpbWUoZW5kX3RpbWVfc3RyKTsKCiAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKHN0YXJ0VGltZSk7CgogICAgICB3aGlsZSAoY3VycmVudFRpbWUgPD0gZW5kVGltZSkgewogICAgICAgIGF2YWlsYWJsZVRpbWVTbG90cy5wdXNoKHt2YWx1ZTogdGhpcy5mb3JtYXRUaW1lKGN1cnJlbnRUaW1lKSwgbGFiZWw6IHRoaXMuZm9ybWF0VGltZShjdXJyZW50VGltZSl9KTsKICAgICAgICBjdXJyZW50VGltZSA9IHRoaXMuYWRkTWludXRlcyhjdXJyZW50VGltZSwgZHVyYXRpb24pOyAvLyBJbmNyZW1lbnQgYnkgZHVyYXRpb24sIG5vdCBpbnRlcnZhbAogICAgICAgIGN1cnJlbnRUaW1lID0gdGhpcy5hZGRNaW51dGVzKGN1cnJlbnRUaW1lLCBpbnRlcnZhbCk7IC8vIEFkZCB0aGUgcmVtYWluaW5nIGludGVydmFsCiAgICAgIH0KICAgICAgCiAgICAgIGNvbnN0IGRhdGVPYmplY3QgPSBuZXcgRGF0ZShkYXRlX3NlbGVjdGVkKTsKICAgICAgbGV0IG5ld190aW1lc2xvdCA9IFtdOwogICAgICAvLyBGb3JtYXQgaXQgYXMgYSBkYXRlIHN0cmluZwogICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gZGF0ZU9iamVjdC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07CiAgICAgIGZvciAobGV0IGk9MDsgaTxpdGVtLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgaWYgKGl0ZW1baV0uZGF0ZSA9PSBmb3JtYXR0ZWREYXRlKSB7CiAgICAgICAgICBjb25zdCBkYXRlT2JqZWN0ID0gbmV3IERhdGUoaXRlbVtpXS50aW1lKTsKCiAgICAgICAgICAvLyBGb3JtYXQgaXQgYXMgYSB0aW1lIHN0cmluZwogICAgICAgICAgLy8gQ3JlYXRlIGFuIEludGwuRGF0ZVRpbWVGb3JtYXQgb2JqZWN0IHdpdGggdGhlIGRlc2lyZWQgdGltZSB6b25lCiAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7CiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJywKICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsCiAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnLAogICAgICAgICAgICB0aW1lWm9uZTogJ1VUQycgLy8gU2V0IHRoZSBkZXNpcmVkIHRpbWUgem9uZQogICAgICAgICAgfSk7CgogICAgICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlIG9iamVjdAogICAgICAgICAgY29uc3QgdGltZVN0cmluZyA9IGZvcm1hdHRlci5mb3JtYXQoZGF0ZU9iamVjdCk7CiAgICAgICAgICBuZXdfdGltZXNsb3QgPSBhdmFpbGFibGVUaW1lU2xvdHMuZmlsdGVyKGl0ZW0gPT4gaXRlbS52YWx1ZSAhPT0gdGltZVN0cmluZyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnNvbGUubG9nKCdhdmFpbGFibGUgdGltZXNsb3Q6ICcsIGF2YWlsYWJsZVRpbWVTbG90cyk7ICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCduZXdfdGltZXNsb3QnLG5ld190aW1lc2xvdCkKICAgICAgcmV0dXJuIG5ld190aW1lc2xvdC5sZW5ndGggPiAwID8gbmV3X3RpbWVzbG90IDogYXZhaWxhYmxlVGltZVNsb3RzOwogICAgfSwKICAgIGFkZE1pbnV0ZXModGltZSwgbWludXRlcykgewogICAgICByZXR1cm4gbmV3IERhdGUodGltZS5nZXRUaW1lKCkgKyBtaW51dGVzICogNjAwMDApOwogICAgfSwKICAgIGZvcm1hdFRpbWUodGltZSkgewogICAgICByZXR1cm4gdGltZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywgeyBob3VyMTI6IHRydWUgfSk7CiAgICB9LAogICAgZmluZERhdGVSYW5nZUluZGV4KGRhdGVSYW5nZXMsIHRhcmdldERhdGUpIHsKICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRhcmdldERhdGUpOyAvLyBDb252ZXJ0IHRhcmdldERhdGUgdG8gYSBEYXRlIG9iamVjdAogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVSYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSB9ID0gZGF0ZVJhbmdlc1tpXTsKCiAgICAgICAgaWYgKGRhdGUgPj0gbmV3IERhdGUoc3RhcnREYXRlKSAmJiBkYXRlIDw9IG5ldyBEYXRlKGVuZERhdGUpKSB7CiAgICAgICAgICByZXR1cm4gaTsgLy8gUmV0dXJuIHRoZSBpbmRleCBpZiB0aGUgZGF0ZSBpcyB3aXRoaW4gdGhlIHJhbmdlCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiAtMTsgLy8gUmV0dXJuIC0xIGlmIHRoZSBkYXRlIGlzIG5vdCBmb3VuZCBpbiBhbnkgcmFuZ2UKICAgIH0sCiAgICBoYW5kbGVEYXRlU2VsZWN0ZWQocGFyYW1zLCBpdGVtKSB7CiAgICAgIGxldCByYW5nZSA9IGl0ZW0udGltZVNsb3RbdGhpcy5maW5kRGF0ZVJhbmdlSW5kZXgoaXRlbS50aW1lU2xvdCwgcGFyYW1zKV07CiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RpbWVzbG90IGluZm8gaXM6ICcsIHJhbmdlKTsKICAgICAgdGhpcy5taW5UaW1lID0gcmFuZ2Uuc3RhcnRUaW1lOwogICAgICB0aGlzLm1heFRpbWUgPSByYW5nZS5lbmRUaW1lOwogICAgICB0aGlzLmR1cmF0aW9uID0gcmFuZ2UuZHVyYXRpb247CiAgICAgIGNvbnNvbGUubG9nKCdyYW5nZTogJyxyYW5nZSk7CgogICAgICBsZXQgYm9va2VkX2NvdW50ZXIgPSAwOwogICAgICBmb3IgKGxldCBpPTA7IGk8aXRlbS5jYXJ0SXRlbS5sZW5ndGg7IGkrKykgewogICAgICAgIGlmKHRoaXMuZm9ybWF0TG9uZ0RhdGUocGFyYW1zKSA9PSBpdGVtLmNhcnRJdGVtW2ldLmRhdGUpIGJvb2tlZF9jb3VudGVyKys7CiAgICAgIH0KICAgICAgdGhpcy5zbG90ID0gcmFuZ2UuY2FwYWNpdHkgLSBib29rZWRfY291bnRlcjsKICAgICAgY29uc29sZS5sb2coJ3JlbWFpbmluZyBzbG90IGZvciBkYXRlOiAnLHRoaXMuZm9ybWF0TG9uZ0RhdGUocGFyYW1zKSwgJyBpczogJywgdGhpcy5zbG90KQoKICAgICAgaWYgKHJhbmdlLmR1cmF0aW9uICE9PSBudWxsKSB7CiAgICAgICAgdGhpcy5vcGVuX3RpbWUgPSBmYWxzZTsKICAgICAgICB0aGlzLnRpbWUgPSAnJzsKICAgICAgICB0aGlzLmF2YWlsYWJsZV90aW1lc2xvdCA9IHRoaXMuY3JlYXRlQXZhaWxhYmxlVGltZVNsb3QocmFuZ2Uuc3RhcnRUaW1lLCByYW5nZS5lbmRUaW1lLCByYW5nZS5kdXJhdGlvbiwgcmFuZ2UuaW50ZXJ2YWwsIHBhcmFtcywgaXRlbS5jYXJ0SXRlbSkKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLm9wZW5fdGltZSA9IHRydWU7CiAgICAgIH0KICAgICAgLy8gVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWQKICAgICAgdGhpcy5kYXRlID0gcGFyYW1zOwogICAgICB0aGlzLnNlcnZpY2UgPSBpdGVtOwogICAgICBjb25zb2xlLmxvZygnU2VsZWN0ZWQgZGF0ZTonLCBwYXJhbXMsIGl0ZW0pOwogICAgfSwKICAgIGdldERpc2FibGVkRGF0ZXMoZGF0ZXMpIHsKICAgICAgaWYgKGRhdGVzID09PSB1bmRlZmluZWQpIHJldHVybjsKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCd0aGUgZGF0ZXM6ICcsIGRhdGVzKQogICAgICBsZXQgZW5hYmxlZERhdGVzID0gW107CiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTsgLy8gR2V0IHRvZGF5J3MgZGF0ZSBhcyBhIERhdGUgb2JqZWN0CgogICAgICBmb3IgKGNvbnN0IGRhdGUgb2YgZGF0ZXMpIHsKICAgICAgICBjb25zdCBmcm9tID0gbmV3IERhdGUoZGF0ZS5zdGFydERhdGUpOyAvLyBDb252ZXJ0IHRvIERhdGUgb2JqZWN0CiAgICAgICAgY29uc3QgdG8gPSBuZXcgRGF0ZShkYXRlLmVuZERhdGUpOyAvLyBDb252ZXJ0IHRvIERhdGUgb2JqZWN0CgogICAgICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiBkYXRlcyB3aXRoaW4gdGhlICdmcm9tJyBhbmQgJ3RvJyByYW5nZQogICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoZnJvbSk7CiAgICAgICAgd2hpbGUgKGN1cnJlbnREYXRlIDw9IHRvKSB7CiAgICAgICAgICBlbmFibGVkRGF0ZXMucHVzaChjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pOwogICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyAxKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IGRpc2FibGVfZGF0ZV9ieV9zbG90ID0gdGhpcy5kaXNhYmxlX2RhdGVfYnlfc2xvdF9mdW5jKCk7CgogICAgICByZXR1cm4gewogICAgICAgIGN1c3RvbVByZWRpY3RvcjogZGF0ZSA9PiB7CiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07IC8vIENvbnZlcnQgZGF0ZSB0byBhIHN0cmluZwogICAgICAgICAgLy8gRGlzYWJsZSBwYXN0IGRheXMKICAgICAgICAgIGlmIChkYXRlIDwgdG9kYXkpIHJldHVybiB0cnVlOwoKICAgICAgICAgIGlmICh0aGlzLmRhdGVfY2hlY2tlZCA9PSBmYWxzZSkgewogICAgICAgICAgICBpZiAoZGlzYWJsZV9kYXRlX2J5X3Nsb3QuaW5jbHVkZXMoZm9ybWF0dGVkRGF0ZSkpIHsKICAgICAgICAgICAgICB0aGlzLmRhdGVfY2hlY2tlZCA9PSB0cnVlOwogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICAvLyBFbmFibGUgdG9kYXkncyBkYXRlIGFuZCBkYXRlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkYXRlIHJhbmdlCiAgICAgICAgICByZXR1cm4gIWVuYWJsZWREYXRlcy5pbmNsdWRlcyhmb3JtYXR0ZWREYXRlKTsKICAgICAgICB9LAogICAgICB9OwogICAgfSwKICAgIGFzeW5jIGdldF9zZXJ2aWNlKCkgewogICAgICB0cnkgewogICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kYXBvbGxvLnF1ZXJ5KHsKICAgICAgICAgIHF1ZXJ5OiByZXF1aXJlKCdAL2dyYXBocWwvU2VydmljZUZpbmQuZ3FsJyksCiAgICAgICAgICB2YXJpYWJsZXM6IHsgaWQ6IHBhcnNlSW50KHRoaXMuJHJvdXRlLnBhcmFtcy5zZXJ2aWNlSWQpfQogICAgICAgIH0pOwogICAgICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlLmRhdGEuc2VydmljZVswXTsKICAgICAgICB0aGlzLmRpc3BsYXlTZXJ2aWNlID0gcmVzcG9uc2UuZGF0YS5zZXJ2aWNlWzBdLm5hbWU7CiAgICAgICAgY29uc29sZS5sb2coJ3NlcnZpY2VfZGF0YScsIHRoaXMuZGF0YSk7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgbGlrZTonLCBlcnJvcik7CiAgICAgIH0KICAgIH0sCiAgfSwKICBtb3VudGVkKCkgewogICAgdGhpcy5nZXRfc2VydmljZSgpOwogIH0KfQo="},{"version":3,"sources":["ServiceDetails.vue"],"names":[],"mappings":";AAkFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ServiceDetails.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"container\">\n    <div class=\"jumbotron\">\n      <img class=\"service-image-one\" :src=\"data.image\" />\n\n      <div class=\"text-content-service-details\">\n        <h1 class=\"display-4 service_category_title_home\">{{ data.name}}</h1>\n        <hr class=\"my-4\">\n        <p>{{ data.description }}</p>\n      </div>\n    </div>\n    <div v-if=\"err_notif\" class=\"alert alert-danger alert-dismissible fade show\" role=\"alert\">\n      {{ err_message }} <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <p class=\"pick-date-msg\">Pick the Date That Works for You</p>\n        <datepicker\n          class=\"time\"\n          :use-utc=\"true\"\n          :disabled-dates=\"getDisabledDates(data.timeSlot)\"\n          :day-cell-content=\"params => format_date(params)\"\n          :inline=\"true\"\n          @selected=\"params => handleDateSelected(params, data)\"\n        ></datepicker>\n      </div>\n      <div class=\"col-md-6 hidden-sm hidden-xs service_list_customer_timeslot\">\n        <div class=\"offcanvas_timeslot_info\">\n          <h1 v-if=\"displayService != ''\">{{ displayService }}</h1>\n          <form @submit.prevent=\"submitForm\" class=\"form-slot-picker\">\n            <div v-if=\"open_time == false\">\n              <p>Duration: {{ duration }}</p>\n              <p>Available Slot: {{ slot }}</p>\n              <div v-if=\"time == '' && available_timeslot.length > 0\">\n                <p>Available timeslot:</p>\n                <div class=\"scrollable-container\">\n                  <div class=\"scrollable-list\">\n                    <div v-for=\"(timeOption, index) in available_timeslot\" :key=\"index\">\n                      <label class=\"radio-label\">\n                        <input\n                          type=\"radio\"\n                          :value=\"timeOption.value\"\n                          v-model=\"time\"\n                          name=\"timeOption\"\n                          class=\"radio-input\"\n                        />\n                        {{ timeOption.label }}\n                      </label>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div v-else-if=\"time == '' && available_timeslot.length <= 0\">\n                <p v-if=\"maxTime != ''\">No open time slots on this day.</p>\n                <p v-else>Select a date for your appointment.</p>\n              </div>\n              <div v-else>\n                <p @click.prevent=\"changeTime\">Selected Time: {{ time }}</p>\n              </div>\n            </div>\n            <div v-else>\n              <p>Available Slot: {{ slot > 50 ? 50 : slot }}</p>\n              <p v-if=\"minTime != '' && maxTime != ''\">Select time from {{ minTime }} to {{ maxTime }}</p>\n              <vue2-timepicker\n                v-model=\"time\"\n                :hour-range=\"[[startHour(),endHour()]]\"\n                lazy\n                hide-clear-button\n                @change=\"onTimeSelected()\"\n              />\n              <p v-if=\"time != ''\">Selected Time: {{ time }}</p>\n            </div>\n            <input v-if=\"time != ''\" type=\"submit\" value=\"submit\">\n          </form>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</template>\n\n<script>\nimport { required, helpers } from '@vuelidate/validators';\nimport { useVuelidate } from '@vuelidate/core'\nimport Datepicker from 'vuejs-datepicker';\nimport Vue2Timepicker from 'vue2-timepicker';\nexport default {\n  name: 'ServiceDetails',\n  setup () { return { v$: useVuelidate() } },\n  components: { \n    Datepicker,\n    Vue2Timepicker,\n  },\n  data() {\n    return {\n      timeslot: [],\n      data: [],\n      date_checked: false,\n      minTime: '',\n      maxTime: '',\n      duration: '',\n      time: '',\n      available_timeslot: [],\n      date: '',\n      service: '',\n      displayService: '',\n      open_time: false,\n      slot: 0,\n      err_message: '',\n      err_notif: false,\n    }\n  }, \n  validations() {\n    const min_time = value => {\n      const selectedTime = new Date(`1970-01-01T${this.convertTo24HourFormat(value)}`);\n      console.log('min_time val: ', value, this.minTime)\n      const mintime = new Date(`1970-01-01T${this.convertTo24HourFormat(this.minTime)}`);\n      console.log('min_time result: ', selectedTime >= mintime)\n      return selectedTime >= mintime;\n    };\n    const max_time = value => {\n      const selectedTime = new Date(`1970-01-01T${this.convertTo24HourFormat(value)}`);\n      console.log('max_time val: ', value, this.maxTime)\n      const maxtime = new Date(`1970-01-01T${this.convertTo24HourFormat(this.maxTime)}`);\n      console.log('max_time result: ', selectedTime <= maxtime)\n      return selectedTime <= maxtime;\n    };\n    return {\n      time: {\n        required,\n        // validTime(value) {\n        //   const timePattern = /^([01]\\d|2[0-3]):([0-5]\\d)$/;\n        //   return timePattern.test(value);\n        // },\n        min_time: helpers.withMessage('The min time must be ' + this.minTime, min_time) ,     \n        max_time: helpers.withMessage('The max time must be ' + this.maxTime, max_time) ,     \n      },\n    }\n  },\n  methods: {\n    handleError(errMsg) {\n      this.err_message = errMsg;\n      this.err_notif = true;\n      setTimeout(() => this.err_notif = false, 10000);\n    },\n    isTimeInFormat() {\n      const timePattern = /^(0[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9] (AM|PM)$/;\n      return timePattern.test(this.time);\n    },\n    onTimeSelected() {\n      this.time = this.convertTo12HourFormat(this.time);\n    },\n    async create_cart_item() {\n      try {\n        const date = this.date;\n        const service_id = this.service.id;\n        const time = this.time;\n        console.log('serviceid is ', service_id)\n        console.log('date ', date);\n        console.log('time ', time)\n\n        const response = await this.$apollo.mutate({\n          mutation: require('@/graphql/CartItemCreate.gql'),\n          variables: {\n            serviceId: service_id,\n            date: date,\n            time: time,\n          },\n        });\n        console.log('response from server create cart item',response);\n        if (response.data.createCartItem.errors.length < 1) {\n          alert('Item added to the cart successfully!');\n          // this.$router.push('/cart')\n        } else {\n          this.handleError(response.data.createCartItem.errors[0]);\n        }\n      } catch (error) {\n        console.error('Error in create_cart_item:', error);\n        // Handle the error here, e.g., show an error message to the user.\n      }\n    },\n    convertTo24HourFormat(time12) {\n      // Split the input time into hours, minutes, and AM/PM parts\n      const [timePart, ampm] = time12.split(' ');\n      const [hours, minutes, seconds] = timePart.split(':');\n\n      // Parse the hours as an integer\n      let convertedHours = parseInt(hours, 10);\n\n      // Adjust the hours based on AM or PM\n      if (ampm.toUpperCase() === 'PM' && convertedHours !== 12) {\n        convertedHours += 12;\n      } else if (ampm.toUpperCase() === 'AM' && convertedHours === 12) {\n        convertedHours = 0;\n      }\n      // Create the 24-hour format time string\n      const convertedTime = `${String(convertedHours).padStart(2, '0')}:${minutes}:${seconds}`;\n\n      return convertedTime;\n    },\n    convertTo12HourFormat(time24) {\n      const [hours, minutes] = time24.split(\":\");\n      let ampm = \"AM\";\n      let convertedHours = parseInt(hours, 10);\n      if (convertedHours >= 12) {\n        ampm = \"PM\";\n        if (convertedHours > 12) {\n          convertedHours -= 12;\n        }\n      } else if (convertedHours === 0) {\n        convertedHours = 12; // Midnight in 12-hour format is 12:00 AM\n      }\n      const new_time = `${String(convertedHours).padStart(2, \"0\")}:${minutes}:00 ${ampm}`;\n      return new_time;\n    },\n    async submitForm() {\n      this.minTime = this.convertTo12HourFormat(this.minTime);\n      this.maxTime = this.convertTo12HourFormat(this.maxTime);\n      this.v$.time.$touch();\n      if (this.v$.$error) {\n        console.log('error');\n        console.log('error time: ', this.time);\n        console.log('errormsg: ', this.v$.$errors);\n      } else {\n        await this.create_cart_item();\n      }\n      this.minTime = this.convertTo24HourFormat(this.minTime);\n      this.maxTime = this.convertTo24HourFormat(this.maxTime);\n      const time24 = this.time.trim();\n      if (time24.match(/^\\d{2}:\\d{2}$/)) {\n        this.convertedTime = this.convertTo12HourFormat(time24);\n      }\n      console.log('UPDATED TIME: ',this.convertedTime);\n    },\n    startHour(){\n      if (this.date == this.dateToday()) {\n        const hour = this.getCurrentHour();\n        if (hour >= parseInt(this.minTime.split(\":\")[0], 10)) return hour + 1;\n      } else {\n        return parseInt(this.minTime.split(\":\")[0], 10);\n      }\n    },\n    endHour(){\n      return parseInt(this.maxTime.split(\":\")[0], 10);\n    },\n    disable_date_by_slot_func() {\n      // console.log('DISABLE DATE BY SLOT FUNC ')\n      const service_category = [this.data];\n      let disable_date_by_slot = [];\n\n      for (let i = 0; i < service_category.length; i++) {\n        for (let j = 0; j < service_category[i].cartItemTally.length; j++) {\n          // Use findDateRangeIndex to check if the date is in the range\n          let index = this.findDateRangeIndex(service_category[i].timeSlot, service_category[i].cartItemTally[j].date);\n          if (index !== -1) {\n            // console.log('the date: ', service_category[i].cartItemTally[j].date, ' found in ', service_category[i].timeSlot[index].startDate,service_category[i].timeSlot[index].endDate)\n            let capacity = service_category[i].timeSlot[index].capacity;\n            // console.log('capacity >= service_category[i].cartItemTally[j].count',capacity >= service_category[i].cartItemTally[j].count,capacity,service_category[i].cartItemTally[j].count)\n            if (service_category[i].cartItemTally[j].count >= capacity) disable_date_by_slot.push(service_category[i].cartItemTally[j].date);\n          }\n        }\n      }\n      console.log('disable_date_by_slot: ',disable_date_by_slot)\n      return disable_date_by_slot;\n    },\n    format_date(params) {\n      return params.date\n    },\n    formatLongDate(dateString) {\n      const dateObject = new Date(dateString);\n\n      // Get the year, month, and day components\n      const year = dateObject.getFullYear();\n      const month = (dateObject.getMonth() + 1).toString().padStart(2, \"0\"); // Adding 1 because months are 0-based\n      const day = dateObject.getDate().toString().padStart(2, \"0\");\n\n      // Create the \"YYYY-MM-DD\" formatted date string\n      return `${year}-${month}-${day}`;\n    },\n    getCurrentHour() {\n      const currentDate = new Date();\n      const currentHour = currentDate.getHours();\n\n      return parseInt(currentHour);\n    },\n    dateToday() {\n      // Create a Date object with the desired date (e.g., the current date)\n      const currentDate = new Date();\n\n      // Get the day, month, and year components\n      const day = currentDate.getDate(); // 1-31\n      const month = currentDate.getMonth() + 1; // 0-11 (January is 0, so add 1)\n      const year = currentDate.getFullYear(); // 4-digit year\n      const formattedDay = String(day).padStart(2, '0');\n      const formattedMonth = String(month).padStart(2, '0');\n      return `${year}-${formattedMonth}-${formattedDay}`;\n    },\n    parseTime(timeStr) {\n      const [hours, minutes] = timeStr.split(':').map(Number);\n      const date = new Date();\n      date.setHours(hours, minutes, 0, 0);\n      return date;\n    },\n    createAvailableTimeSlot(start_time_str, end_time_str, duration, interval, date_selected, item) {\n      const date_selected_formatted = this.formatLongDate(date_selected);\n      const hour = this.getCurrentHour();\n      let edited_start_time = 0;\n      if (this.dateToday() == date_selected_formatted) {\n        const timeComponents = start_time_str.split(\":\");\n        // Extract the hour component (the first element after splitting)\n        const selectedHour = parseInt(timeComponents[0], 10);\n        if (hour >= selectedHour) {\n          console.log(hour >= start_time_str, 'HOUR')\n          edited_start_time = `${hour + 1}:00:00`;\n        }\n      }\n      console.log('edited_start_time',edited_start_time)\n      console.log(this.dateToday() == date_selected_formatted,this.dateToday(),date_selected_formatted)\n      if (duration == null) duration = 0;\n      const availableTimeSlots = [];\n      const startTime = edited_start_time == 0 ? this.parseTime(start_time_str) : this.parseTime(edited_start_time);\n      console.log('startTime: ', startTime, 'this.parseTime(start_time_str): ', this.parseTime(start_time_str))\n      const endTime = this.parseTime(end_time_str);\n\n      let currentTime = new Date(startTime);\n\n      while (currentTime <= endTime) {\n        availableTimeSlots.push({value: this.formatTime(currentTime), label: this.formatTime(currentTime)});\n        currentTime = this.addMinutes(currentTime, duration); // Increment by duration, not interval\n        currentTime = this.addMinutes(currentTime, interval); // Add the remaining interval\n      }\n      \n      const dateObject = new Date(date_selected);\n      let new_timeslot = [];\n      // Format it as a date string\n      const formattedDate = dateObject.toISOString().split('T')[0];\n      for (let i=0; i<item.length; i++) {\n        if (item[i].date == formattedDate) {\n          const dateObject = new Date(item[i].time);\n\n          // Format it as a time string\n          // Create an Intl.DateTimeFormat object with the desired time zone\n          const formatter = new Intl.DateTimeFormat('en-US', {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric',\n            timeZone: 'UTC' // Set the desired time zone\n          });\n\n          // Format the date object\n          const timeString = formatter.format(dateObject);\n          new_timeslot = availableTimeSlots.filter(item => item.value !== timeString);\n        }\n      }\n      console.log('available timeslot: ', availableTimeSlots);      \n      console.log('new_timeslot',new_timeslot)\n      return new_timeslot.length > 0 ? new_timeslot : availableTimeSlots;\n    },\n    addMinutes(time, minutes) {\n      return new Date(time.getTime() + minutes * 60000);\n    },\n    formatTime(time) {\n      return time.toLocaleTimeString('en-US', { hour12: true });\n    },\n    findDateRangeIndex(dateRanges, targetDate) {\n      const date = new Date(targetDate); // Convert targetDate to a Date object\n      for (let i = 0; i < dateRanges.length; i++) {\n        const { startDate, endDate } = dateRanges[i];\n\n        if (date >= new Date(startDate) && date <= new Date(endDate)) {\n          return i; // Return the index if the date is within the range\n        }\n      }\n      return -1; // Return -1 if the date is not found in any range\n    },\n    handleDateSelected(params, item) {\n      let range = item.timeSlot[this.findDateRangeIndex(item.timeSlot, params)];\n        // console.log('timeslot info is: ', range);\n      this.minTime = range.startTime;\n      this.maxTime = range.endTime;\n      this.duration = range.duration;\n      console.log('range: ',range);\n\n      let booked_counter = 0;\n      for (let i=0; i<item.cartItem.length; i++) {\n        if(this.formatLongDate(params) == item.cartItem[i].date) booked_counter++;\n      }\n      this.slot = range.capacity - booked_counter;\n      console.log('remaining slot for date: ',this.formatLongDate(params), ' is: ', this.slot)\n\n      if (range.duration !== null) {\n        this.open_time = false;\n        this.time = '';\n        this.available_timeslot = this.createAvailableTimeSlot(range.startTime, range.endTime, range.duration, range.interval, params, item.cartItem)\n      } else {\n        this.open_time = true;\n      }\n      // This method will be called when a date is selected\n      this.date = params;\n      this.service = item;\n      console.log('Selected date:', params, item);\n    },\n    getDisabledDates(dates) {\n      if (dates === undefined) return;\n      \n      console.log('the dates: ', dates)\n      let enabledDates = [];\n      const today = new Date(); // Get today's date as a Date object\n\n      for (const date of dates) {\n        const from = new Date(date.startDate); // Convert to Date object\n        const to = new Date(date.endDate); // Convert to Date object\n\n        // Create an array of dates within the 'from' and 'to' range\n        const currentDate = new Date(from);\n        while (currentDate <= to) {\n          enabledDates.push(currentDate.toISOString().split('T')[0]);\n          currentDate.setDate(currentDate.getDate() + 1);\n        }\n      }\n\n      const disable_date_by_slot = this.disable_date_by_slot_func();\n\n      return {\n        customPredictor: date => {\n          const formattedDate = date.toISOString().split('T')[0]; // Convert date to a string\n          // Disable past days\n          if (date < today) return true;\n\n          if (this.date_checked == false) {\n            if (disable_date_by_slot.includes(formattedDate)) {\n              this.date_checked == true;\n              return true;\n            }\n          }\n          // Enable today's date and dates within the specified date range\n          return !enabledDates.includes(formattedDate);\n        },\n      };\n    },\n    async get_service() {\n      try {\n        const response = await this.$apollo.query({\n          query: require('@/graphql/ServiceFind.gql'),\n          variables: { id: parseInt(this.$route.params.serviceId)}\n        });\n        this.data = response.data.service[0];\n        this.displayService = response.data.service[0].name;\n        console.log('service_data', this.data);\n      } catch (error) {\n        console.error('Error creating like:', error);\n      }\n    },\n  },\n  mounted() {\n    this.get_service();\n  }\n}\n</script>\n\n<style>\n.service-image-one {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.pick-date-msg {\n  margin-top: 15px;\n}\n\n.text-content-service-details {\n  color: #ddd;\n  height: 400px;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  padding: 20px;\n  background-color: rgba(31, 28, 28, 0.493);\n  z-index: 3;\n}\n\n.vdp-datepicker__calendar {\n  width: 100%;\n}\n\n.day .day-content {\n  border: 1px solid blue;\n  border-radius: 15px;\n  padding: 7px;\n  width: 50px;\n}\n</style>\n"]}]}